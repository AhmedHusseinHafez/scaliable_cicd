# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

platform :ios do

  # MARK: - 1: Global variables
  $keychain_name = SecureRandom.uuid
  $keychain_password = SecureRandom.hex(100)
  $is_ci = ENV['CI'] || false
  $price_tier = 0 # Free
  $copyright = "¬© #{Time.now.year} ScalableTech. All rights reserved."
  $primary_category = "BUSINESS" 
  #  "BOOKS"

  # MARK: - 2: Hooks
  before_all do |lane, options|
    ensure_git_status_clean unless $is_ci
    UI.message "Starting lane: #{lane}"
  end

  after_all do |lane, options|
    remove_keychain
    UI.success "Successfully completed lane: #{lane}"
  end

  error do |lane, exception, options|
    remove_keychain
    UI.error "Lane #{lane} failed with error: #{exception.message}"
  end

  # MARK: - 3: Keychain Management
  desc "Remove Keychain from CI"
  private_lane :remove_keychain do |options|
    if $is_ci
      if File.exist?(File.expand_path("~/Library/Keychains/#{$keychain_name}-db"))
        UI.important "Deleting keychain #{$keychain_name}"
        delete_keychain(name: $keychain_name)
      else
        UI.important "No keychain file found to delete"
      end
    end
  end

  desc "Setup Keychain for match on CI"
  private_lane :setup_keychain do |options|
    create_keychain(
      name: $keychain_name,
      password: $keychain_password,
      default_keychain: true,
      unlock: true,
      timeout: 0,
      lock_when_sleeps: false
    )
  end

  # MARK: - 4: Authentication
  desc "Configure App Store Connect API authentication"
  private_lane :setup_app_store_connect do |options|
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"],
    )
  end

  # MARK: - 5: Code Signing
  desc "Setup code signing with match"
  ##################################################################################
  # üì¶ setup_code_signing
  #
  # Purpose:
  #   Sets up the code signing environment for building and distributing the app.
  #   This lane is designed mainly for CI/CD environments.
  #
  # How it works:
  #   - If running on CI, it creates a temporary keychain (via `setup_keychain`)
  #   - Uses `match` with readonly: true to download existing certificates and provisioning profiles
  #   - Adds them to the active keychain so Xcode and Fastlane can sign the build
  #
  # Parameters:
  #   - type: The provisioning type ("appstore", "development", etc.)
  #
  # Notes:
  #   - Does NOT create or update certificates (readonly mode)
  #   - Safe for automated build pipelines
  #
  ##################################################################################
  private_lane :setup_code_signing do |options|
    type = options[:type] || "appstore"
    
    setup_keychain if $is_ci
    
    match(
      type: type,
      readonly: true,
      keychain_name: $keychain_name,
      keychain_password: $keychain_password,
      app_identifier: ENV["APP_STORE_APP_IDENTIFIER"]
    )
  end

  # MARK: - 6: Build IOS
  desc "Build the iOS app (dynamic flavor, obfuscation optional)"
  private_lane :build_flutter_ios_app do |options|
    method = options[:method] || "app-store"
    flavor = options[:flavor] || ENV["SCHEME"] || "staging" 
    obfuscate = options[:obfuscate] || false

    UI.header "üèóÔ∏è  Starting iOS build for flavor: #{flavor} (Method: #{method})"

    flutter_root = File.expand_path("../..", __dir__)
    UI.message "üöÄ flutter_root: #{flutter_root}"
    Dir.chdir(flutter_root) do
      if File.exist?("#{flutter_root}/pubspec.yaml")
        build_command = "flutter build ipa --release --flavor #{flavor}"
        build_command += " --obfuscate --split-debug-info=build/app/outputs/symbols/#{flavor}" if obfuscate

        UI.message "üöÄ Running: #{build_command}"
        sh(build_command)
      else
        UI.user_error!("‚ùå Could not find pubspec.yaml in #{flutter_root}. Make sure Fastlane is run from the iOS directory.")
      end
    end

    # Automatically detect latest IPA for the given flavor
    ipa_dir = File.expand_path("../../build/ios/ipa", __dir__)
    ipa_pattern =
      if flavor == "prod"
        "#{ipa_dir}/*.ipa"
      else
        "#{ipa_dir}/*#{flavor}*.ipa"
      end

    ipa_files = Dir[ipa_pattern]
    UI.message "üöÄ ipa_files: #{ipa_files}"
    latest_ipa = ipa_files.max_by { |f| File.mtime(f) }
    UI.message "üöÄ latest_ipa: #{latest_ipa}"

    unless latest_ipa
      UI.user_error!("‚ùå No IPA found for flavor '#{flavor}' in #{ipa_dir}.")
    end

    UI.success "üì¶ Found latest IPA for #{flavor}: #{latest_ipa}"

    # Return path so lanes like :staging or :production can use it
    latest_ipa
  end

  # MARK: - 7: Deployment
  desc "Push a new beta build to TestFlight"
  lane :staging do |options|
    version_type = options[:type] || "patch" # major | minor | patch
    setup_ci if $is_ci
    
    setup_app_store_connect
    setup_code_signing(type: "appstore")
    
    auto_versioning(type: version_type)
    UI.message "üöÄ Using version #{version_info[:version]} (build #{version_info[:build]})"

    # Build the obfuscated staging IPA using Flutter
    ipa_path = build_flutter_ios_app(flavor: "staging", obfuscate: true)
    UI.message "üöÄ ipa_path from staging: #{ipa_path}"

    upload_to_testflight(
      ipa: ipa_path,
      expire_previous_builds: true,
      skip_waiting_for_build_processing: true,
      submit_for_review: false,
      automatic_release: false,
      notify_external_testers: false,
      changelog: ENV["CHANGELOG"] || "Staging obfuscated build üöÄ"
    )
    
    UI.success "üöÄ Successfully uploaded staging build to TestFlight!"
  end
  
  desc "Push a production build to App Store"
  lane :production do |options|
    version_type = options[:type] || "patch" # major | minor | patch
    setup_ci if $is_ci
    
    # Ensure we're on the main/master branch
    ensure_git_branch(branch: 'main')
    
    setup_app_store_connect
    setup_code_signing(type: "appstore")
    
    auto_versioning(type: version_type)
        
    # Build the obfuscated staging IPA using Flutter
    ipa_path = build_flutter_ios_app(method: "app-store", flavor: "prod", obfuscate: true)
    UI.message "üöÄ ipa_path from staging: #{ipa_path}"
    app_rating_config_path_var = app_rating_config_ios_path
    
    upload_to_app_store(
      # price_tier: $price_tier,
      ipa: ipa_path,
      app_rating_config_path: app_rating_config_path_var,
      primary_category: $primary_category,
      copyright: $copyright,
      skip_metadata: false,
      skip_screenshots: true,
      submit_for_review: true,
      automatic_release: false,
      force: true,
      precheck_include_in_app_purchases: false,
      run_precheck_before_submit: false,
    )
    
    # Tag the release
    add_git_tag(
      tag: "v#{version}",
      message: "Release version #{version}"
    )
    push_git_tags
    
    UI.success "üéâ Successfully uploaded to App Store!"
  end

  # MARK: - 8: Utility: Setup CI
  desc "Get Flutter version and build number from pubspec.yaml"
  private_lane :get_flutter_version do
    flutter_root = File.expand_path("../..", __dir__)
    UI.message "üöÄ flutter_root: #{flutter_root}"

    Dir.chdir(flutter_root) do
      pubspec_path = "#{flutter_root}/pubspec.yaml"
      unless File.exist?(pubspec_path)
        UI.user_error!("‚ùå pubspec.yaml not found at #{pubspec_path}")
      end

      content = File.read(pubspec_path)
      version_line = content.lines.find { |line| line =~ /^version:/ }
      unless version_line
        UI.user_error!("‚ùå Couldn't find 'version:' in pubspec.yaml")
      end

      raw_version = version_line.split(":").last.strip
      version, build = raw_version.split("+")
      build ||= "0"

      unless version =~ /^\d+(\.\d+){0,2}$/
        UI.user_error!("‚ùå Invalid version format: #{version}")
      end

      UI.message "üöÄ version_line: #{version_line}"
      {
        version: version,
        build: build.to_i,
        pubspec_path: pubspec_path,
        raw_line: version_line
      }
    end
  end

  desc "Automatically bump version & build in pubspec.yaml and sync with iOS"
  private_lane :auto_versioning do |options|
    version_type = options[:type] || "patch" # major | minor | patch
    xcodeproj_path = "Runner.xcodeproj"

    flutter_info = get_flutter_version
    old_version = flutter_info[:version]
    old_build = flutter_info[:build]
    pubspec_path = flutter_info[:pubspec_path]

    UI.message "üì¶ Current Flutter version: #{old_version}+#{old_build}"

    # --- Bump semantic version ---
    segments = old_version.split(".").map(&:to_i)
    segments << 0 while segments.size < 3

    case version_type
    when "major"
      segments[0] += 1
      segments[1] = 0
      segments[2] = 0
    when "minor"
      segments[1] += 1
      segments[2] = 0
    when "patch"
      segments[2] += 1
    else
      UI.user_error!("‚ùå Invalid bump type '#{version_type}'. Use major, minor, or patch.")
    end

    new_version = segments.join(".")
    new_build = old_build + 1
    new_raw_version = "#{new_version}+#{new_build}"

    # --- Update pubspec.yaml ---
    content = File.read(pubspec_path)
    new_content = content.gsub(/^version: .+$/, "version: #{new_raw_version}")
    File.write(pubspec_path, new_content)
    UI.success "üìù Updated pubspec.yaml to #{new_raw_version}"

    # --- Update iOS project ---
    increment_version_number(
      version_number: new_version,
      xcodeproj: xcodeproj_path
    )
    increment_build_number(
      build_number: new_build
    )

    UI.success "üì≤ Synced iOS version to #{new_version} (Build #{new_build})"

    { version: new_version, build: new_build }
  end


  desc "Set app_rating_config_path variable"
  lane :app_rating_config_ios_path do
    fastlane_root = File.expand_path("./", __dir__)
    app_rating_config_path = "#{fastlane_root}/metadata/app_rating_config_path.json"
    app_rating_config_path
  end


  # üîÑ sync_certificates
  #
  # Purpose:
  #   Syncs the latest signing certificates and provisioning profiles from the Match repository.
  #   This lane is intended for local setup and manual maintenance, not CI.
  #
  # How it works:
  #   - Calls `match` with readonly: false
  #   - Downloads or generates new certificates/profiles if needed
  #   - Saves them locally so they can be used by Xcode or other Fastlane lanes
  #
  # Parameters:
  #   - type: The provisioning type ("development", "appstore", etc.)
  #
  # Notes:
  #   - Will upload new certificates to the Match repo if they don‚Äôt exist
  #   - Useful during initial project setup or when certificates are rotated
  #
  #
  desc "Download certificates and provisioning profiles"
  lane :sync_certificates do |options|
    type = options[:type] || "development"
    
    match(
      type: type,
      readonly: false,
      app_identifier: ENV["APP_STORE_APP_IDENTIFIER"]
    )
    
    UI.success "‚úÖ Certificates synced for #{type}"
  end

  desc "Update app metadata"
  lane :update_metadata do
    setup_ci if $is_ci
    setup_app_store_connect
    setup_code_signing(type: "appstore")

    upload_app_privacy_details_to_app_store(
        json_path: "fastlane/app_privacy_details.json"
    ) 

    app_rating_config_path_var = app_rating_config_ios_path

    upload_to_app_store(
     submission_information: {
        content_rights_has_rights: true,
        content_rights_contains_third_party: true
      },
      app_rating_config_path: app_rating_config_path_var,
      primary_category: $primary_category,
      copyright: $copyright,
      skip_binary_upload: true,
      skip_screenshots: true,
      force: true, # Skip HTMl report verification
      run_precheck_before_submit: false,
    )
    
    UI.success "üìù Metadata updated successfully!"
  end

  desc "Clean build artifacts"
  lane :clean do
    clear_derived_data
    clean_build_artifacts
    
    UI.success "üßπ Cleaned build artifacts!"
  end

  desc "Setup project for first time"
  lane :setup do
    # Install dependencies if using CocoaPods
    cocoapods if File.exist?('Podfile')
    
    # Sync certificates
    sync_certificates(type: "development")
    sync_certificates(type: "appstore")
    
    UI.success "‚úÖ Project setup complete!"
  end

end